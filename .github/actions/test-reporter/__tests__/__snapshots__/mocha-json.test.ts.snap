// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`mocha-json tests report from ./reports/mocha-json test results matches snapshot 1`] = `
TestRunResult {
  "path": "fixtures/mocha-json.json",
  "suites": Array [
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "Test 1",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "Passing test",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Test 1 Test 1.1",
          "tests": Array [
            TestCaseResult {
              "error": Object {
                "details": "Error: Some error
    at Object.throwError (lib\\\\main.js:2:9)
    at Context.<anonymous> (test\\\\main.test.js:15:11)
    at processImmediate (internal/timers.js:461:21)",
                "line": 2,
                "message": "Some error",
                "path": "lib/main.js",
              },
              "name": "Exception in target unit",
              "result": "failed",
              "time": 0,
            },
            TestCaseResult {
              "error": Object {
                "details": "AssertionError [ERR_ASSERTION]: Expected values to be strictly equal:

false !== true

    at Context.<anonymous> (test\\\\main.test.js:11:14)
    at processImmediate (internal/timers.js:461:21)",
                "line": 11,
                "message": "Expected values to be strictly equal:

false !== true
",
                "path": "test/main.test.js",
              },
              "name": "Failing test",
              "result": "failed",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Test 2",
          "tests": Array [
            TestCaseResult {
              "error": Object {
                "details": "Error: Some error
    at Context.<anonymous> (test\\\\main.test.js:22:11)
    at processImmediate (internal/timers.js:461:21)",
                "line": 22,
                "message": "Some error",
                "path": "test/main.test.js",
              },
              "name": "Exception in test",
              "result": "failed",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/main.test.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": null,
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "Skipped test",
              "result": "skipped",
              "time": 0,
            },
            TestCaseResult {
              "error": Object {
                "details": "Error: Timeout of 1ms exceeded. For async tests and hooks, ensure \\"done()\\" is called; if returning a Promise, ensure it resolves. (C:\\\\Users\\\\Michal\\\\Workspace\\\\dorny\\\\test-reporter\\\\reports\\\\mocha\\\\test\\\\second.test.js)
    at listOnTimeout (internal/timers.js:554:17)
    at processTimers (internal/timers.js:497:7)",
                "line": undefined,
                "message": "Timeout of 1ms exceeded. For async tests and hooks, ensure \\"done()\\" is called; if returning a Promise, ensure it resolves. (C:\\\\Users\\\\Michal\\\\Workspace\\\\dorny\\\\test-reporter\\\\reports\\\\mocha\\\\test\\\\second.test.js)",
                "path": undefined,
              },
              "name": "Timeout test",
              "result": "failed",
              "time": 8,
            },
          ],
        },
      ],
      "name": "test/second.test.js",
      "totalTime": undefined,
    },
  ],
  "totalTime": 12,
}
`;

exports[`mocha-json tests report from mochajs/mocha test results matches snapshot 1`] = `
TestRunResult {
  "path": "fixtures/external/mocha/mocha-test-results.json",
  "suites": Array [
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "class BufferedWorkerPool constructor",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should apply defaults",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "class BufferedWorkerPool instance method run()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should deserialize the result",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should serialize the options object",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "class BufferedWorkerPool instance method run() when passed a non-string filepath",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should reject",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "class BufferedWorkerPool instance method run() when passed no arguments",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should reject",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "class BufferedWorkerPool instance method stats()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the object returned by \`workerpool.Pool#stats\`",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "class BufferedWorkerPool instance method terminate() when called with \`force\`",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should delegate to the underlying pool w/ \\"force\\" behavior",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "class BufferedWorkerPool instance method terminate() when called without \`force\`",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should delegate to the underlying pool w/o \\"force\\" behavior",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "class BufferedWorkerPool static method create()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return a BufferedWorkerPool instance",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "class BufferedWorkerPool static method create() when passed no arguments",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "class BufferedWorkerPool static method serializeOptions()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return a serialized string",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "class BufferedWorkerPool static method serializeOptions() when called multiple times with the same object",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not perform serialization twice",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return the same value",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "class BufferedWorkerPool static method serializeOptions() when passed no arguments",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/node-unit/buffered-worker-pool.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "cli/config findConfig()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should look for one of the config files using findup-sync",
              "result": "success",
              "time": 2,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should support an explicit \`cwd\`",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "cli/config loadConfig() when config file parsing fails",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "cli/config loadConfig() when parsing succeeds when supplied a filepath with \\".cjs\\" extension",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should use the JS parser",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "cli/config loadConfig() when parsing succeeds when supplied a filepath with \\".js\\" extension",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should use the JS parser",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "cli/config loadConfig() when parsing succeeds when supplied a filepath with \\".json\\" extension",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should use the JSON parser",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "cli/config loadConfig() when parsing succeeds when supplied a filepath with \\".jsonc\\" extension",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should use the JSON parser",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "cli/config loadConfig() when parsing succeeds when supplied a filepath with \\".yaml\\" extension",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should use the YAML parser",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "cli/config loadConfig() when parsing succeeds when supplied a filepath with \\".yml\\" extension",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should use the YAML parser",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "cli/config loadConfig() when supplied a filepath with unsupported extension",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should use the JSON parser",
              "result": "success",
              "time": 2,
            },
          ],
        },
      ],
      "name": "test/node-unit/cli/config.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "node-flags impliesNoTimeouts()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return true for inspect flags",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "node-flags isNodeFlag() for all allowed node env flags which conflict with mocha flags",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "--require should return false",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "-r should return false",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "node-flags isNodeFlag() for all allowed node environment flags",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "--abort-on-uncaught-exception should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--conditions should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--debug-arraybuffer-allocations should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--debug-port should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--diagnostic-dir should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--disable-proto should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--disallow-code-generation-from-strings should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--enable-source-maps should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--es-module-specifier-resolution should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--experimental-import-meta-resolve should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--experimental-json-modules should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--experimental-loader should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--experimental-modules should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--experimental-policy should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--experimental-repl-await should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--experimental-report should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--experimental-specifier-resolution should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--experimental-vm-modules should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--experimental-wasi-unstable-preview1 should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--experimental-wasm-modules should return true",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--experimental-worker should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--force-context-aware should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--frozen-intrinsics should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--heapsnapshot-signal should return true",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--http-parser should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--http-server-default-timeout should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--huge-max-old-generation-size should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--icu-data-dir should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--input-type should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--insecure-http-parser should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--inspect should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--inspect-brk should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--inspect-port should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--inspect-publish-uid should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--interpreted-frames-native-stack should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--jitless should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--loader should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--max-http-header-size should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--max-old-space-size should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--napi-modules should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--no-deprecation should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--no-force-async-hooks-checks should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--no-node-snapshot should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--no-warnings should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--openssl-config should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--pending-deprecation should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--perf-basic-prof should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--perf-basic-prof-only-functions should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--perf-prof should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--perf-prof-unwinding-info should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--policy-integrity should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--preserve-symlinks should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--preserve-symlinks-main should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--prof-process should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--redirect-warnings should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--report-compact should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--report-dir should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--report-directory should return true",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--report-filename should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--report-on-fatalerror should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--report-on-signal should return true",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--report-signal should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--report-uncaught-exception should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--stack-trace-limit should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--throw-deprecation should return true",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--title should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--tls-cipher-list should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--tls-keylog should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--tls-max-v1.2 should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--tls-max-v1.3 should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--tls-min-v1.0 should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--tls-min-v1.1 should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--tls-min-v1.2 should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--tls-min-v1.3 should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--trace-deprecation should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--trace-event-categories should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--trace-event-file-pattern should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--trace-events-enabled should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--trace-exit should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--trace-sigint should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--trace-sync-io should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--trace-tls should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--trace-uncaught should return true",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--trace-warnings should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--track-heap-objects should return true",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--unhandled-rejections should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--use-bundled-ca should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--use-largepages should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--use-openssl-ca should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--v8-pool-size should return true",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "--zero-fill-buffers should return true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "node-flags isNodeFlag() special cases",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return true for \\"es-staging\\"",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return true for \\"gc-global\\"",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return true for \\"harmony\\" itself",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return true for \\"use-strict\\"",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return true for flags starting with \\"--v8-\\"",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return true for flags starting with \\"harmony-\\" or \\"harmony_\\"",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return true for flags starting with \\"preserve-symlinks\\"",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return true for flags starting with \\"trace-\\" or \\"trace_\\"",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "node-flags isNodeFlag() when expecting leading dashes",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should require leading dashes",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "node-flags unparseNodeFlags()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should handle multiple v8 flags",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle single v8 flags",
              "result": "success",
              "time": 1,
            },
          ],
        },
      ],
      "name": "test/node-unit/cli/node-flags.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "options loadOptions() \\"extension\\" handling when user does not supply \\"extension\\" option",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should retain the default",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() \\"extension\\" handling when user supplies \\"extension\\" option",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not concatenate the default value",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() \\"ignore\\" handling",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not split option values by comma",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() \\"spec\\" handling when user supplies \\"spec\\" in config and positional arguments",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should place both - unsplitted - into the positional arguments array",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() config priority",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should prioritize args over rc file",
              "result": "success",
              "time": 72,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should prioritize package.json over defaults",
              "result": "success",
              "time": 77,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should prioritize rc file over package.json",
              "result": "success",
              "time": 75,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when called with a one-and-done arg \\"h\\"",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return basic parsed arguments and flag",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when called with a one-and-done arg \\"help\\"",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return basic parsed arguments and flag",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when called with a one-and-done arg \\"list-interfaces\\"",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return basic parsed arguments and flag",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when called with a one-and-done arg \\"list-reporters\\"",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return basic parsed arguments and flag",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when called with a one-and-done arg \\"V\\"",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return basic parsed arguments and flag",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when called with a one-and-done arg \\"version\\"",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return basic parsed arguments and flag",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when no parameter provided",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return an object containing positional args, defaults, and anti-reloading flags",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when parameter provided package.json when called with package = false (\`--no-package\`)",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not look for package.json",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return parsed args and default config",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set package = false",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when parameter provided package.json when path to package.json (\`--package <path>\`) is invalid",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when parameter provided package.json when path to package.json (\`--package <path>\`) is valid",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not try to find a package.json",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return merged options incl. package.json opts",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set package = false",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when parameter provided package.json when path to package.json unspecified",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return merged options incl. found package.json",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set package = false",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when parameter provided rc file when called with config = false (\`--no-config\`)",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not attempt to find a config file",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not attempt to load a config file",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return parsed args, default config and package.json",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set config = false",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when parameter provided rc file when called with unspecified config when an rc file would be found",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attempt to load file at found path",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should look for a config",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set config = false",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when parameter provided rc file when called with unspecified config when an rc file would not be found",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should look for a config",
              "result": "success",
              "time": 2,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not attempt to load a config file",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set config = false",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "options loadOptions() when parameter provided rc file when path to config (\`--config <path>\`) is invalid",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attempt to load file at path",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not look for a config",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should throw to warn the user",
              "result": "success",
              "time": 1,
            },
          ],
        },
      ],
      "name": "test/node-unit/cli/options.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "helpers list() when given a comma-delimited string",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return a flat array",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "helpers list() when provided a flat array",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return a flat array",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "helpers list() when provided a nested array",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return a flat array",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "helpers validateLegacyPlugin() when a plugin throws an exception upon load",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should fail and report the original error",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "helpers validateLegacyPlugin() when used with \\"reporter\\" key",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should disallow an array of names",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should fail to recognize an unknown reporter",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "helpers validateLegacyPlugin() when used with an \\"interfaces\\" key",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should disallow an array of names",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should fail to recognize an unknown interface",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "helpers validateLegacyPlugin() when used with an unknown plugin type",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should fail",
              "result": "success",
              "time": 1,
            },
          ],
        },
      ],
      "name": "test/node-unit/cli/run-helpers.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "command run builder array type",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should include option extension",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option file",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option global",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option ignore",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option reporter-option",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option require",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option spec",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option watch-files",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option watch-ignore",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "command run builder boolean type",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should include option allow-uncaught",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option async-only",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option bail",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option check-leaks",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option color",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option delay",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option diff",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option exit",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option forbid-only",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option forbid-pending",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option full-trace",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option growl",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option inline-diffs",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option invert",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option list-interfaces",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option list-reporters",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option no-colors",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option parallel",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option recursive",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option sort",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option watch",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "command run builder number type",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should include option jobs",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option retries",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "command run builder string type",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should include option config",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option fgrep",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option grep",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option package",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option reporter",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option slow",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option timeout",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should include option ui",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/node-unit/cli/run.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "Mocha instance method addFile()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should add the given file to the files array",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method lazyLoadFiles()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the \`Mocha\` instance",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method lazyLoadFiles() when passed \`true\`",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should enable lazy loading",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method lazyLoadFiles() when passed a non-\`true\` value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should enable eager loading",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method loadFiles()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should execute the optional callback if given",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should load all files from the files array",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method parallelMode() when \`Mocha\` is running in Node.js",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the Mocha instance",
              "result": "success",
              "time": 6,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method parallelMode() when \`Mocha\` is running in Node.js when \`Mocha\` instance in serial mode when passed \`true\` value when \`Mocha\` instance is in \`INIT\` state",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should enable parallel mode",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method parallelMode() when \`Mocha\` is running in Node.js when \`Mocha\` instance in serial mode when passed \`true\` value when \`Mocha\` instance is not in \`INIT\` state",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method parallelMode() when \`Mocha\` is running in Node.js when \`Mocha\` instance in serial mode when passed non-\`true\` value when \`Mocha\` instance is in \`INIT\` state",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should enable serial mode",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method parallelMode() when \`Mocha\` is running in Node.js when parallel mode is already disabled",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not swap the Runner, nor change lazy loading setting",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method parallelMode() when \`Mocha\` is running in Node.js when parallel mode is already enabled",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not swap the Runner, nor change lazy loading setting",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method reporter() when a reporter exists relative to the \\"mocha\\" module path",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should load from module path",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method reporter() when a reporter exists relative to the \\"mocha\\" module path when the reporter throws upon load",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw \\"invalid reporter\\" exception",
              "result": "success",
              "time": 2,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should warn about the error before throwing",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method reporter() when a reporter exists relative to the cwd",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should load from current working directory",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method reporter() when a reporter exists relative to the cwd when the reporter throws upon load",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw \\"invalid reporter\\" exception",
              "result": "success",
              "time": 2,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should warn about the error before throwing",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method unloadFiles()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should delegate Mocha.unloadFile() for each item in its list of files",
              "result": "success",
              "time": 9,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not be allowed when the current instance is already disposed",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should reset referencesCleaned and allow for next run",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha static method unloadFile()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should unload a specific file from cache",
              "result": "success",
              "time": 1,
            },
          ],
        },
      ],
      "name": "test/node-unit/mocha.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner constructor",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should start in \\"IDLE\\" state",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner event EVENT_RUN_END",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should change the state to COMPLETE",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance method isParallelMode()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance method linkPartialObjects()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the runner",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance method run()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should emit \`EVENT_RUN_BEGIN\`",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance method run() when a suite has a bail flag when an event contains an error and has positive failures when subsequent files already started running",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should cleanly terminate the thread pool",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance method run() when a suite has a bail flag when an event contains an error and has positive failures when subsequent files have not yet been run",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should cleanly terminate the thread pool",
              "result": "success",
              "time": 2,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should cleanly terminate the thread pool",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance method run() when a suite has a bail flag when no event contains an error",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not force-terminate",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance method run() when a worker fails",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should delegate to Runner#uncaught",
              "result": "success",
              "time": 3,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should recover",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance method run() when instructed to link objects",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should create object references",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance method run() when instructed to link objects when event data object is missing an ID",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should result in an uncaught exception",
              "result": "success",
              "time": 3,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance method run() when suite should bail when an event contains an error and has positive failures when subsequent files already started running",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should cleanly terminate the thread pool",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance method run() when suite should bail when an event contains an error and has positive failures when subsequent files have not yet been run",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should cleanly terminate the thread pool",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance method run() when suite should bail when no event contains an error",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not force-terminate",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance method workerReporter()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return its context",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "parallel-buffered-runner ParallelBufferedRunner instance property _state",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should disallow an invalid state transition",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/node-unit/parallel-buffered-runner.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "ParallelBuffered constructor",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should listen for Runner events",
              "result": "success",
              "time": 8,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should listen for Runner events expecting to occur once",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "ParallelBuffered event on any other event listened for",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should populate its \`events\` array with SerializableEvents",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "ParallelBuffered event on EVENT_RUN_END",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should remove all listeners",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "ParallelBuffered instance method done",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should execute its callback with a SerializableWorkerResult",
              "result": "success",
              "time": 6,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should reset its \`events\` prop",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/node-unit/reporters/parallel-buffered.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "serializer function deserialize when passed a non-object value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the value",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer function deserialize when passed a SerializedWorkerResult object",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the result of \`SerializableWorkerResult.deserialize\` called on the value",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer function deserialize when passed an object value which is not a SerializedWorkerResult",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the value",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer function deserialize when passed nothing",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return \`undefined\`",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer function serialize when not passed anything",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return \`undefined\`",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer function serialize when passed a non-object value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the value",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer function serialize when passed an object value having a \`serialize\` method",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the result of the \`serialize\` method",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer function serialize when passed an object value w/o a \`serialize\` method",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the value",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent constructor when called with a non-object \`rawObject\`",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw \\"invalid arg type\\" error",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent constructor when called without \`eventName\`",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw \\"invalid arg value\\" error",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent instance method serialize",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should freeze the instance",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should mutate the instance in-place",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent instance method serialize when passed an error",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not retain not-own props",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should retain own props",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should serialize the error",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent instance method serialize when passed an object containing a nested prop with an Error value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should serialize the Error",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent instance method serialize when passed an object containing a non-\`serialize\` method",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should remove the method",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent instance method serialize when passed an object containing a top-level prop with an Error value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should serialize the Error",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent instance method serialize when passed an object containing an array",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should serialize the array",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent instance method serialize when passed an object containing an object with a \`serialize\` method",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call the \`serialize\` method",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent instance method serialize when passed an object with a \`serialize\` method",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call the \`serialize\` method",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent static method create",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should instantiate a SerializableEvent",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent static method deserialize",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return a new object w/ null prototype",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent static method deserialize when passed a falsy parameter",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw \\"invalid arg type\\" error",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent static method deserialize when passed value contains \`data\` prop",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should ignore __proto__",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent static method deserialize when passed value contains \`data\` prop when \`data\` prop contains a nested serialized Error prop",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should create an Error instance from the nested serialized Error prop",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent static method deserialize when passed value contains an \`error\` prop",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should create an Error instance from the prop",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent static method deserialize when passed value data contains a prop beginning with \\"$$\\"",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should create a new prop having a function value",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should create a new prop returning the original value",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should remove the prop with the \\"$$\\" prefix",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableEvent static method deserialize when the value data contains a prop with an array value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should deserialize each prop",
              "result": "success",
              "time": 18,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableWorkerResult constructor",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should add a readonly \`__type\` prop",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableWorkerResult instance method serialize",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call \`SerializableEvent#serialize\` of each of its events",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return a read-only value",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableWorkerResult static method create",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return a new SerializableWorkerResult instance",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableWorkerResult static method deserialize",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call SerializableEvent#deserialize on each item in its \`events\` prop",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return the deserialized value",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableWorkerResult static method isSerializedWorkerResult when passed an instance",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return \`true\`",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableWorkerResult static method isSerializedWorkerResult when passed an object with an appropriate \`__type\` prop",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return \`true\`",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "serializer SerializableWorkerResult static method isSerializedWorkerResult when passed an object without an appropriate \`__type\` prop",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return \`false\`",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/node-unit/serializer.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "stackTraceFilter() on browser",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "does not strip out other bower_components",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "stackTraceFilter() on node on POSIX OS",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "does not ignore other bower_components and components",
              "result": "skipped",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should get a stack-trace as a string and prettify it",
              "result": "skipped",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not replace absolute path which has cwd as infix",
              "result": "skipped",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should replace absolute with relative paths",
              "result": "skipped",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "stackTraceFilter() on node on Windows",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should work on Windows",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/node-unit/stack-trace-filter.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "utils function canonicalType()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return \\"asyncfunction\\" if the parameter is an async function",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return \\"buffer\\" if the parameter is a Buffer",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "utils function cwd()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the current working directory",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "utils function type()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return \\"error\\" if the parameter is an Error",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return \\"function\\" if the parameter is an async function",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/node-unit/utils.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "worker when run as main process",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 69,
            },
          ],
        },
        TestGroupResult {
          "name": "worker when run as worker process",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should register itself with workerpool",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "worker when run as worker process function run() when called with empty \\"filepath\\" argument",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should reject",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "worker when run as worker process function run() when called without arguments",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should reject",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "worker when run as worker process function run() when passed a non-string \`options\` value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should reject",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "worker when run as worker process function run() when passed an invalid string \`options\` value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should reject",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "worker when run as worker process function run() when the file at \\"filepath\\" argument is unloadable",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should reject",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "worker when run as worker process function run() when the file at \\"filepath\\" is loadable",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call Mocha#run",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle \\"--require\\"",
              "result": "success",
              "time": 2,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle \\"--ui\\"",
              "result": "success",
              "time": 3,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should remove all uncaughtException listeners",
              "result": "success",
              "time": 4,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should remove all unhandledRejection listeners",
              "result": "success",
              "time": 4,
            },
          ],
        },
        TestGroupResult {
          "name": "worker when run as worker process function run() when the file at \\"filepath\\" is loadable when run twice",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should initialize only once",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "worker when run as worker process function run() when the file at \\"filepath\\" is loadable when serialization fails",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should reject",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "worker when run as worker process function run() when the file at \\"filepath\\" is loadable when serialization succeeds",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should resolve with a SerializedWorkerResult",
              "result": "success",
              "time": 1,
            },
          ],
        },
      ],
      "name": "test/node-unit/worker.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "Context nested",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should work",
              "result": "success",
              "time": 3,
            },
          ],
        },
        TestGroupResult {
          "name": "Context Siblings sequestered sibling",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should work",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Context Siblings sibling verifiction",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should allow test siblings to modify shared context",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should have reset this.calls before describe",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not have value set within a sibling describe",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "methods retries",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the number of retries",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "methods slow()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the slow",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "methods timeout()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the timeout",
              "result": "success",
              "time": 1,
            },
          ],
        },
      ],
      "name": "test/unit/context.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "durations when fast",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not highlight",
              "result": "success",
              "time": 11,
            },
          ],
        },
        TestGroupResult {
          "name": "durations when reasonable",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should highlight in yellow",
              "result": "success",
              "time": 52,
            },
          ],
        },
        TestGroupResult {
          "name": "durations when slow",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should highlight in red",
              "result": "success",
              "time": 103,
            },
          ],
        },
      ],
      "name": "test/unit/duration.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "Errors createForbiddenExclusivityError() when Mocha instance is not running in a worker process",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should output a message regarding --forbid-only",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Errors createForbiddenExclusivityError() when Mocha instance is running in a worker process",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should output a message regarding incompatibility",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Errors createInvalidInterfaceError()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should include expected code in thrown interface errors",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Errors createInvalidReporterError()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should include expected code in thrown reporter errors",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "Errors deprecate()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should cache the message",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should coerce its parameter to a string",
              "result": "success",
              "time": 2,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should ignore falsy messages",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Errors isMochaError() when provided a non-error",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return false",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Errors isMochaError() when provided an Error object having a known Mocha error code",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Errors isMochaError() when provided an Error object with a non-Mocha error code",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return false",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Errors warn()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call process.emitWarning",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should ignore falsy messages",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not cache messages",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/errors.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "global leaks",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should cause tests to fail",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should pass when accepted",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should pass when prefixed \\"mocha-\\"",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should pass with wildcard",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/globals.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "Mocha .grep()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should add a RegExp to the mocha.options object",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should convert grep string to a RegExp",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should covert grep regex-like string to a RegExp",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return its parent Mocha object for chainability",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha \\"fgrep\\" option",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should escape and convert string to a RegExp",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha \\"grep\\" option",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should add a RegExp to the mocha.options object",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should convert string to a RegExp",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha \\"invert\\" option",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should add a Boolean to the mocha.options object",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/grep.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "async hooks",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "one",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "three",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "two",
              "result": "success",
              "time": 1,
            },
          ],
        },
      ],
      "name": "test/unit/hook-async.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "serial nested",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "bar",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "foo",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "serial nested hooks",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "one",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "two",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/hook-sync-nested.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "serial hooks",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "one",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "three",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "two",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/hook-sync.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "hook timeout",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should work",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/hook-timeout.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "Hook error",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should get the hook._error when called without arguments",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the hook._error",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Hook reset",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call Runnable.reset",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should reset the error state",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/hook.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "Mocha constructor",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set _cleanReferencesAfterRun to true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha constructor when \`global\` option is an \`Array\`",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attempt to set globals",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha constructor when \`parallel\` option is true and \`jobs\` option <= 1",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not enable parallel mode",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha constructor when \`parallel\` option is true and \`jobs\` option > 1",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should enable parallel mode",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha constructor when \`parallel\` option is true when \`enableGlobalSetup\` option is present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should toggle global setup fixtures",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha constructor when \`parallel\` option is true when \`enableGlobalTeardown\` option is present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should configure global teardown fixtures",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha constructor when \`parallel\` option is true when \`globalSetup\` option is present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should configure global setup fixtures",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha constructor when \`parallel\` option is true when \`globalTeardown\` option is present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should configure global teardown fixtures",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha constructor when \`retries\` option is not present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not attempt to set retries",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha constructor when \`retries\` option is present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attempt to set retries\`",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha constructor when \`rootHooks\` option is truthy",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "shouid attempt to set root hooks",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha constructor when \`timeout\` option is \`false\`",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attempt to set timeout",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha constructor when \`timeout\` option is \`undefined\`",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not attempt to set timeout",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method _runGlobalFixtures()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should execute multiple fixtures in order",
              "result": "success",
              "time": 3,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method allowUncaught()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the allowUncaught option to false",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the allowUncaught option to true",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method asyncOnly()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the asyncOnly option to false",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the asyncOnly option to true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method bail()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method bail() when provided a falsy argument",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should unset the \\"bail\\" flag on the root suite",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method bail() when provided no arguments",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set the \\"bail\\" flag on the root suite",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method checkLeaks()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set the checkLeaks option to true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method cleanReferencesAfterRun()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the _cleanReferencesAfterRun attribute",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the _cleanReferencesAfterRun attribute to false",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method color()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the color option to false",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the color option to true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method delay()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the delay option to true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method diff()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set the diff option to true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method diff() when provided \`false\` argument",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set the diff option to false",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method dispose()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should dispose previous test runner",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should dispose the root suite",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should unload the files",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method forbidOnly()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the forbidOnly option to false",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the forbidOnly option to true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method forbidPending()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the forbidPending option to false",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the forbidPending option to true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method fullTrace()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the fullTrace option to false",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the fullTrace option to true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method global()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be an empty array initially",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method global() when argument is invalid",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not modify the whitelist when given empty array",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not modify the whitelist when given empty string",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method global() when argument is valid",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should add contents of string array to the whitelist",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should add string to the whitelist",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not have duplicates",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method growl()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 57,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method growl() if capable of notifications",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set the growl option to true",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method growl() if not capable of notifications",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set the growl option to false",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method hasGlobalSetupFixtures() when no global setup fixtures are present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return \`false\`",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method hasGlobalSetupFixtures() when one or more global setup fixtures are present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return \`true\`",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method hasGlobalTeardownFixtures() when no global teardown fixtures are present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return \`false\`",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method hasGlobalTeardownFixtures() when one or more global teardown fixtures are present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return \`true\`",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method inlineDiffs()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the inlineDiffs option to false",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the inlineDiffs option to true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method invert()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the invert option to true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method noHighlighting()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the noHighlighting option to true",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method parallelMode() when \`Mocha\` is running in a browser",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method reporter()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should keep reporterOption on options",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should support legacy reporterOptions",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method rootHooks()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be chainable",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method rootHooks() when provided a single \\"after all\\" hook",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attach it to the root suite",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method rootHooks() when provided a single \\"after each\\" hook",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attach it to the root suite",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method rootHooks() when provided a single \\"before all\\" hook",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attach it to the root suite",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method rootHooks() when provided a single \\"before each\\" hook",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attach it to the root suite",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method rootHooks() when provided multiple \\"after all\\" hooks",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attach each to the root suite",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method rootHooks() when provided multiple \\"after each\\" hooks",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attach each to the root suite",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method rootHooks() when provided multiple \\"before all\\" hooks",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attach each to the root suite",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method rootHooks() when provided multiple \\"before each\\" hooks",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attach each to the root suite",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should execute the callback when complete",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should initialize the stats collector",
              "result": "skipped",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should instantiate a reporter",
              "result": "success",
              "time": 3,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() Base reporter initialization",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should configure the Base reporter",
              "result": "success",
              "time": 3,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() Base reporter initialization when \\"color\\" options is set",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should configure the Base reporter",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() Runner initialization",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should instantiate a Runner",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() Runner initialization when \\"global\\" option is present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should configure global vars",
              "result": "success",
              "time": 3,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() Runner initialization when \\"grep\\" option is present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should configure \\"grep\\"",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when \\"growl\\" option is present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should initialize growl support",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when a reporter instance has a \\"done\\" method",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call the reporter \\"done\\" method",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when a run has finished and is called again",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not call \`Runner#runAsync()\`",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when a run is in progress",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not call \`Runner#runAsync\`",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when files have been added to the Mocha instance when Mocha is set to eagerly load files",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should eagerly load files",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when files have been added to the Mocha instance when Mocha is set to lazily load files",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not eagerly load files",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when global setup fixtures disabled when global setup fixtures are present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not run global setup fixtures",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when global setup fixtures disabled when global setup fixtures not present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not run global setup fixtures",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when global setup fixtures enabled when global setup fixtures are present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should run global setup fixtures",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when global setup fixtures enabled when global setup fixtures not present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not run global setup fixtures",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when global teardown fixtures disabled when global teardown fixtures are present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not run global teardown fixtures",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when global teardown fixtures disabled when global teardown fixtures not present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not run global teardown fixtures",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when global teardown fixtures enabled when global teardown fixtures are present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should run global teardown fixtures",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when global teardown fixtures enabled when global teardown fixtures are present when global setup fixtures are present and enabled",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should use the same context as returned by \`runGlobalSetup\`",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when global teardown fixtures enabled when global teardown fixtures not present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not run global teardown fixtures",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when Mocha configured for multiple runs and multiple runs are attempted",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call \`Runner#runAsync\` for each call",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should dispose the previous runner",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not throw",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should reset the root Suite between runs",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method run() when the \`Mocha\` instance is already disposed",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not call \`Runner#runAsync\`",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method runGlobalSetup() when a fixture is not present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not attempt to run fixtures",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method runGlobalSetup() when fixture(s) are present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attempt run the fixtures",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method runGlobalTeardown() when a fixture is not present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "not attempt to run the fixtures",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method runGlobalTeardown() when fixture(s) are present",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attempt to run the fixtures",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Mocha instance method unloadFile() when run in a browser",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/mocha.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "overspecified asynchronous resolution method",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should fail when multiple methods are used",
              "result": "success",
              "time": 3,
            },
          ],
        },
      ],
      "name": "test/unit/overspecified-async.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "parseQuery()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should get queryString and return key-value object",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should parse \\"+\\" as a space",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/parse-query.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "plugin module class PluginLoader constructor when passed custom plugins",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should register the custom plugins",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader constructor when passed ignored plugins",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should retain a list of ignored plugins",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader constructor when passed no options",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should populate a registry of built-in plugins",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method finalize() when a plugin has no \\"finalize\\" function",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return an array of raw implementations",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method finalize() when a plugin has one or more implementations",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should omit unused plugins",
              "result": "success",
              "time": 2,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return an object map using \`optionName\` key for each registered plugin",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method finalize() when no plugins have been loaded",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return an empty map",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method load() when called with a falsy value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return false",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method load() when called with an object containing a recognized plugin",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call the associated validator, if present",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should retain the value of any matching property in its mapping",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method load() when called with an object containing no recognized plugin",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return false",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method load() when passed a falsy or non-object value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not call a validator",
              "result": "success",
              "time": 2,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return false",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method load() when passed an object value when a key matches a known named export",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call the associated validator",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not call validators whose keys were not found",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method load() when passed an object value when a key matches a known named export when the value does not pass the associated validator",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method load() when passed an object value when a key matches a known named export when the value passes the associated validator",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should add the implementation to the internal mapping",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not add an implementation of plugins not present",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method load() when passed an object value when no keys match any known named exports",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return false",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method register() when passed a definition w/o an exportName",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method register() when passed a falsy parameter",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method register() when passed a non-object parameter",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method register() when the plugin export name is already in use",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method register() when the plugin export name is ignored",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not register the plugin",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader instance method register() when the plugin export name is not in use",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module class PluginLoader static method create()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return a PluginLoader instance",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module global fixtures plugin global setup when an implementation is a function",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should pass validation",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module global fixtures plugin global setup when an implementation is a primitive",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should fail validation",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module global fixtures plugin global setup when an implementation is an array of functions",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should pass validation",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module global fixtures plugin global setup when an implementation is an array of primitives",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should fail validation",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module global fixtures plugin global teardown when an implementation is a function",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should pass validation",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module global fixtures plugin global teardown when an implementation is a primitive",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should fail validation",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module global fixtures plugin global teardown when an implementation is an array of functions",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should pass validation",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module global fixtures plugin global teardown when an implementation is an array of primitives",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should fail validation",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module root hooks plugin  when a loaded impl is finalized",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should flatten the implementations",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module root hooks plugin  when impl is a function",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should pass validation",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module root hooks plugin  when impl is a primitive",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should fail validation",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module root hooks plugin  when impl is an array",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should fail validation",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "plugin module root hooks plugin  when impl is an object of functions",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should pass validation",
              "result": "skipped",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/plugin-loader.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "using imported describe",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "using imported it",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/required-tokens.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "root",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be a valid suite",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/root.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) if async",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "this.skip() should halt synchronous execution",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "this.skip() should set runnable to pending",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) if timed-out",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should ignore call to \`done\` and not execute callback again",
              "result": "success",
              "time": 11,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when .pending",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not invoke the callback",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when async",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should allow a timeout of 0",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should allow updating the timeout",
              "result": "success",
              "time": 51,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when async when an error is passed",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should invoke the callback",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when async when an exception is thrown",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should invoke the callback",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not throw its own exception if passed a non-object",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when async when an exception is thrown and is allowed to remain uncaught",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "throws an error when it is allowed",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when async when done() is invoked with a non-Error object",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should invoke the callback",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when async when done() is invoked with a string",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should invoke the callback",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when async when the callback is invoked several times with an error",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should emit a single \\"error\\" event",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when async when the callback is invoked several times without an error",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should emit a single \\"error\\" event",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when async without error",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should invoke the callback",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when fn is not a function",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw an error",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when fn returns a non-promise",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should invoke the callback",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when fn returns a promise when the promise is fulfilled with a value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should invoke the callback",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when fn returns a promise when the promise is fulfilled with no value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should invoke the callback",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when fn returns a promise when the promise is rejected",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should invoke the callback",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when fn returns a promise when the promise is rejected without a reason",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should invoke the callback",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when fn returns a promise when the promise takes too long to settle",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw the timeout error",
              "result": "success",
              "time": 12,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when sync when an exception is thrown",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should invoke the callback with error",
              "result": "success",
              "time": 4,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when sync when an exception is thrown and is allowed to remain uncaught",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "throws an error when it is allowed",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when sync without error",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should invoke the callback",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .run(fn) when timeouts are disabled",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not error with timeout",
              "result": "success",
              "time": 6,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .title",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be present",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) .titlePath()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "returns the concatenation of the parent's title path and runnable's title",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #globals",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should allow for whitelisting globals",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #isFailed()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return \`false\` if test is pending",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return \`true\` if test has failed",
              "result": "success",
              "time": 2,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return \`true\` if test has not failed",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #reset",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should reset current run state",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #resetTimeout()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not time out if timeouts disabled after reset",
              "result": "success",
              "time": 21,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #retries(n)",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set the number of retries",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #slow(ms)",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not set the slow threshold if the parameter is not passed",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not set the slow threshold if the parameter is undefined",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set the slow threshold",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #slow(ms) when passed a time-formatted string",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should convert to ms",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #timeout(ms) when value is equal to lower bound given numeric value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set the timeout value to disabled",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #timeout(ms) when value is equal to lower bound given string timestamp",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set the timeout value to disabled",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #timeout(ms) when value is equal to upper bound given numeric value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set the disabled timeout value",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #timeout(ms) when value is less than lower bound",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should clamp to lower bound given numeric",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should clamp to lower bound given timestamp",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #timeout(ms) when value is out-of-bounds given numeric value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set the disabled timeout value",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #timeout(ms) when value is within \`setTimeout\` bounds given numeric value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set the timeout value",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) #timeout(ms) when value is within \`setTimeout\` bounds given string timestamp",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should set the timeout value",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) interesting property id",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should have a permanent identifier",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should have a unique identifier",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) static method toValueOrError",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return an Error if parameter is falsy",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return identity if parameter is truthy",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) when arity == 0",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be .sync",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not be .async",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runnable(title, fn) when arity >= 1",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be .async",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not be .sync",
              "result": "success",
              "time": 1,
            },
          ],
        },
      ],
      "name": "test/unit/runnable.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "Runner instance method _uncaught() when called with a non-Runner context",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method abort()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the Runner",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set _abort property to true",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method allowUncaught()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "async - should allow unhandled errors in hooks to propagate through",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should allow unhandled errors in sync hooks to propagate through",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should allow unhandled errors to propagate through",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not allow unhandled errors in sync hooks to propagate through",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method checkGlobals(test)",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should allow variables that match a wildcard",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should emit \\"fail\\" when a global beginning with \\"d\\" is introduced",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should emit \\"fail\\" when a new global is introduced",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should emit \\"fail\\" when a single new disallowed global is introduced after a single extra global is allowed",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not fail when a new common global is introduced",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should pluralize the error message when several are introduced",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should respect per test whitelisted globals",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should respect per test whitelisted globals but still detect other leaks",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method dispose()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should remove \\"error\\" listeners from a test",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should remove \\"uncaughtException\\" listeners from the process",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should remove all listeners from itself",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method fail()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should emit \\"fail\\"",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should emit \\"fail\\"",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should emit a helpful message when failed with a string",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should emit a helpful message when failed with an Array",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should emit a helpful message when failed with an Object",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should emit a the error when failed with an Error instance",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should emit the error when failed with an Error-like object",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should increment .failures",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should increment \`Runner#failures\`",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not emit \\"end\\" if suite bail is not true",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should recover if the error stack is not writable",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return and not increment failures when test is pending",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should set \`Test#state\` to \\"failed\\"",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method fail() when Runner has stopped when test is not pending when error is not of the \\"multiple done\\" variety",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw a \\"fatal\\" error",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method fail() when Runner has stopped when test is not pending when error is the \\"multiple done\\" variety",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw the \\"multiple done\\" error",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method globalProps()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should include common non enumerable globals",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method globals()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should default to the known globals",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should white-list globals",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method grep()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should update the runner.total with number of matched tests",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should update the runner.total with number of matched tests when inverted",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method grepTotal()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the total number of matched tests",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return the total number of matched tests when inverted",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method hook()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should augment hook title with current test title",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should execute hooks after failed test if suite bail is true",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method isParallelMode()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return false",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method linkPartialObjects()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the Runner",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method run()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should clean references after a run",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should emit \\"retry\\" when a retryable test fails",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not clean references after a run when \`cleanReferencesAfterRun\` is \`false\`",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not leak \`Process.uncaughtException\` listeners",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not throw an exception if something emits EVENT_TEST_END with a non-Test object",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method run() stack traces ginormous",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not hang if overlong error message is multiple lines",
              "result": "success",
              "time": 2,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not hang if overlong error message is single line",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method run() stack traces long",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should display the full stack-trace",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method run() stack traces short",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should prettify the stack-trace",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method runAsync()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should pass through options to Runner#run",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return a Promise with a failure count",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method runTest()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return when no tests to run",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when allow-uncaught is set to true",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should propagate error and throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when provided an object argument when argument is a Pending",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should ignore argument and return",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when provided an object argument when argument is an Error",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should add the \\"uncaught\\" property to the Error",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when provided an object argument when argument is an Error when a Runnable is running or has run",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should clear any pending timeouts",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when provided an object argument when argument is an Error when a Runnable is running or has run when current Runnable has already failed",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not attempt to fail again",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when provided an object argument when argument is an Error when a Runnable is running or has run when current Runnable has been marked pending",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should attempt to fail",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when provided an object argument when argument is an Error when a Runnable is running or has run when the current Runnable has already passed",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should abort the runner without emitting end event",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should fail with the current Runnable and the error",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when provided an object argument when argument is an Error when a Runnable is running or has run when the current Runnable is still running when the current Runnable is a Hook",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not notify run has ended",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not notify test has ended",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should run callback(err) to handle failing hook pattern",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when provided an object argument when argument is an Error when a Runnable is running or has run when the current Runnable is still running when the current Runnable is a Test",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not notify run has ended",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not notify test has ended",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should run callback(err) to handle failing and hooks",
              "result": "success",
              "time": 3,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when provided an object argument when argument is an Error when no Runnables are running",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should fail with a transient Runnable and the error",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when provided an object argument when argument is an Error when no Runnables are running when Runner is IDLE",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should emit start/end events for the benefit of reporters",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when provided an object argument when argument is an Error when no Runnables are running when Runner is RUNNING",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not emit start/end events",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when provided an object argument when argument is an Error when no Runnables are running when Runner is STOPPED",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not emit start/end events, since this presumably would have already happened",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method uncaught() when provided an object argument when argument is not an Error",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should fail with a transient Runnable and a new Error coerced from the object",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "Runner instance method workerReporter()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/runner.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "Suite instance method addSuite()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "adds the suite to the suites collection",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "copies the slow value",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "copies the timeout value",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "sets the parent on the added Suite",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "treats suite as pending if its parent is pending",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method addTest()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "adds the test to the tests collection",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "copies the timeout value",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "sets the parent on the added test",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method afterAll() wraps the passed in function in a Hook",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "adds it to _afterAll",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "appends title to hook",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "uses function name if available",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method afterEach() wraps the passed in function in a Hook",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "adds it to _afterEach",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "appends title to hook",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "uses function name if available",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method bail() when argument is passed",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the Suite object",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method bail() when no argument is passed",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the bail value",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method beforeAll() wraps the passed in function in a Hook",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "adds it to _beforeAll",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "appends title to hook",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "uses function name if available",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method beforeEach() when the suite is pending",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not create a hook",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method beforeEach() wraps the passed in function in a Hook",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "adds it to _beforeEach",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "appends title to hook",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "uses function name if available",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method clone()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should clone the Suite, omitting children",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method constructor",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not throw if the title is a string",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should report listened-for deprecated events as deprecated",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should throw an error if the title isn't a string",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method create()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "does not create a second root suite",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "does not denote the root suite by being titleless",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method eachTest(fn) when there are no nested suites or tests",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return 0",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method eachTest(fn) when there are several levels of nested suites",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the number",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method eachTest(fn) when there are several tests in the suite",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the number",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method filterOnly()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should filter out all other tests and suites if a suite has \`only\`",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should filter out all other tests and suites if a test has \`only\`",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method fullTitle() when there is a parent",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "returns the combination of parent's and suite's title",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method fullTitle() when there is no parent",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "returns the suite title",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method hasOnly()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return false if no suite or test is marked \`only\`",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return true if a suite has \`only\`",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return true if a test has \`only\`",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return true if nested suite has \`only\`",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method markOnly()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call appendOnlySuite on parent",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method reset()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should forward reset to all hooks",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should forward reset to suites and tests",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should reset the \`delayed\` state",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method slow() when argument is passed",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the Suite object",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method slow() when given a string",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should parse it",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method slow() when no argument is passed",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the slow value",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method timeout()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should convert a string to milliseconds",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method timeout() when argument is passed",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the Suite object",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method timeout() when no argument is passed",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the timeout value",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method titlePath() when there is a parent the parent is not the root suite",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "returns the concatenation of parent's and suite's title",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method titlePath() when there is a parent the parent is the root suite",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "returns the suite title",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method titlePath() when there is no parent",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "returns the suite title",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method total() when there are no nested suites or tests",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return 0",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Suite instance method total() when there are several tests in the suite",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return the number",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Test initialization",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not throw if the title is a string",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should throw an error if the title isn't a string",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/suite.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "Test .clone()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should add/keep the retriedTest value",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should copy the currentRetry value",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should copy the file value",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should copy the globals value",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should copy the parent value",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should copy the retries value",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should copy the slow value",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should copy the timeout value",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should copy the title",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Test .isPending()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should be pending when its parent is pending",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should be pending when marked as such",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not be pending by default",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Test .markOnly()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call appendOnlyTest on parent",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "Test .reset()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should call Runnable.reset",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should reset the run state",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/test.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "a test that throws non-extensible",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not pass if throwing async and test is async",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not pass if throwing sync and test is async",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not pass if throwing sync and test is sync",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "a test that throws null",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not pass if throwing async and test is async",
              "result": "success",
              "time": 3,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not pass if throwing sync and test is async",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not pass if throwing sync and test is sync",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "a test that throws undefined",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should not pass if throwing async and test is async",
              "result": "success",
              "time": 2,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not pass if throwing sync and test is async",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not pass if throwing sync and test is sync",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/throw.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "timeouts",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should allow overriding per-test",
              "result": "success",
              "time": 50,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should error on timeout",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "timeouts disabling",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should work with timeout(0)",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "timeouts disabling suite-level",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should work with timeout(0)",
              "result": "success",
              "time": 3,
            },
          ],
        },
        TestGroupResult {
          "name": "timeouts disabling suite-level nested suite",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should work with timeout(0)",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "timeouts disabling using before",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should work with timeout(0)",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "timeouts disabling using beforeEach",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should work with timeout(0)",
              "result": "success",
              "time": 2,
            },
          ],
        },
        TestGroupResult {
          "name": "timeouts disabling using timeout(0)",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should suppress timeout(4)",
              "result": "success",
              "time": 50,
            },
          ],
        },
      ],
      "name": "test/unit/timeout.spec.js",
      "totalTime": undefined,
    },
    TestSuiteResult {
      "groups": Array [
        TestGroupResult {
          "name": "lib/utils canonicalType()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should recognize various types",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils canonicalType() when toString on null or undefined stringifies window",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should recognize null and undefined",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils castArray() when provided a primitive value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return an array containing the primitive value only",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils castArray() when provided an \\"arguments\\" value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return an array containing the arguments",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils castArray() when provided an array value",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return a copy of the array",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils castArray() when provided an object",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return an array containing the object only",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils castArray() when provided no parameters",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return an empty array",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils castArray() when provided null",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return an array containing a null value only",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils clean()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should format a multi line test indented with spaces",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should format a multi line test indented with tabs",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should format a single line test function",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should format es6 arrow functions",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should format es6 arrow functions with implicit return",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should format functions saved in windows style - spaces",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should format functions saved in windows style - tabs",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle empty functions",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle functions with no space between the end and the closing brace",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle functions with parentheses in the same line",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle functions with tabs in their declarations",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle named functions with space after name",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle named functions without space after name",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle newlines in the function declaration",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should remove space character indentation from the function body",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should remove tab character indentation from the function body",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should remove the wrapping function declaration",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils createMap()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should add props from all object parameters to the object",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should add props to the object",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return an object with a null prototype",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils dQuote()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return its input as string wrapped in double quotes",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils escape()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "replaces invalid xml characters",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "replaces the usual xml suspects",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils isPromise()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return false if the object is null",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return false if the value is an object w/o a \\"then\\" function",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return false if the value is not an object",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return true if the value is Promise-ish",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils lookupFiles() when run in browser",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should throw",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils lookupFiles() when run in Node.js",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should delegate to new location of lookupFiles()",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should print a deprecation message",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils slug()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should convert the string to lowercase",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should convert whitespace to dashes",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should disallow consecutive dashes",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should strip non-alphanumeric and non-dash characters",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils sQuote()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return its input as string wrapped in single quotes",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils stringify()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "might get confusing",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should canonicalize the object",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle arrays",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle circular structures in arrays",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle circular structures in functions",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle circular structures in objects",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle empty arrays",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle empty functions (with no properties)",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle empty objects",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle functions",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle functions w/ properties",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle length properties that cannot be coerced to a number",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle non-empty arrays",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle object without an Object prototype",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle Symbol",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle undefined values",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should handle various non-undefined, non-null, non-object, non-array, non-date, and non-function values",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should not freak out if it sees a primitive twice",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should recurse",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return an object representation of a string created with a String constructor",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return Buffer with .toJSON representation",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return Date object with .toISOString() + string prefix",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should return invalid Date object with .toString() + string prefix",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should stringify dates",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils stringify() #Number",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "floats and ints",
              "result": "success",
              "time": 1,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should show the handle -0 situations",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should work well with \`NaN\` and \`Infinity\`",
              "result": "success",
              "time": 0,
            },
            TestCaseResult {
              "error": undefined,
              "name": "should work with bigints when possible",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils stringify() canonicalize example",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should represent the actual full result",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils type()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should recognize various types",
              "result": "success",
              "time": 1,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils type() when toString on null or undefined stringifies window",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should recognize null and undefined",
              "result": "success",
              "time": 0,
            },
          ],
        },
        TestGroupResult {
          "name": "lib/utils uniqueID()",
          "tests": Array [
            TestCaseResult {
              "error": undefined,
              "name": "should return a non-empty string",
              "result": "success",
              "time": 0,
            },
          ],
        },
      ],
      "name": "test/unit/utils.spec.js",
      "totalTime": undefined,
    },
  ],
  "totalTime": 5965,
}
`;
