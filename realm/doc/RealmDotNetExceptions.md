Exceptions
==============

The problem with catching exceptions, if you have any need to map specific types, is how you invoke the mapping code. A macro such as the `CATCH_STD` you see mentioned below can be used to provide a `catch` and then invoke a forwarding function which further processes the exception.

An alternative pattern introduced in the hackathon Rust binding is to wrap the function invocation in a lambda so it can be nested in a `handle_errors` function to provide the wrapping of the lambda in a `try...catch` with further processing. That imposes (a tiny?) overhead on every successful call.

C# Overview
-----------------
The C# implementation described below is based on the Java exceptions but with limitations based on the platform. The essence of the difference is that the JNI layer can throw exceptions direct to Java from C++ but C# needs a delegate calling from C++ to throw the exceptions in _managed space._

A very similar pattern is used to capture the C++ exceptions except we just pass them as a parameter to ConvertException rather than re-throwing as done in the Java code.

@dot
digraph { 
  node[shape = box]
  edge[arrowhead=vee]
  
/* c++ */
node [fontcolor="blue", color="blue"]
set_exception_thrower
ManagedExceptionThrower[shape=invhouse]
coreException [label="a std::exception\n thrown from core"]
ThrowManaged
CATCH_STD
ConvertException
"Binding invalid\n parameter detection"-> ThrowManaged


  /*  C# */
node [fontcolor="orange", color="orange"]
SetupExceptionThrower [label="NativeCommon\n.SetupExceptionThrower"]

"CoreProvider\nconstructor" -> SetupExceptionThrower
ExceptionThrower -> "Switch on numeric code\nthrowing range of c# exceptions"

SetupExceptionThrower -> set_exception_thrower [label="passes pointer to delegate\n NativeCommon.ExceptionThrower"]

set_exception_thrower -> ManagedExceptionThrower [label="sets static\n function pointer"]

coreException ->  CATCH_STD -> ConvertException -> ThrowManaged 
ThrowManaged -> ManagedExceptionThrower [label=" callback with\n code for switch"]
ManagedExceptionThrower -> ExceptionThrower [label="points to\n managed function"]
ExceptionThrower  -> "Exception should be\n caught by user code" [style=dotted]
}

@enddot



Callback Overview
-------------------------

* The C# side declares a delegate which can receive an integer error code and optional string (having a string defined by length > 0)
* A single call is made to set a callback function in the Native DLL to call an instance of this delegate, 
	* the delegate callback will then be used whenever we want to throw exceptions from native. 
	* inside the delegate callback, we would typically switch on the error code to throw different kinds of exceptions
* Our interactions with native code are wrapped in try/catch

Callback Details - Native side
---------------------
We define a typedef for a callback function taking three parameters and a static var to keep a reference to it, publishing a function to set that callback:

```
using ManagedExceptionThrowerT = void(*)(size_t exceptionCode, void* utf8Str, size_t strLen);
static ManagedExceptionThrowerT ManagedExceptionThrower = nullptr;

extern "C" void set_exception_thrower(ManagedExceptionThrowerT userThrower)
{
    ManagedExceptionThrower = userThrower;
}
```

That function can then be invoked from any of our other native functions which have been invoked from the managed environmnent. We assume a `std::string` will typically be generated containing a formatted error message in outfit format. 

```
	std::string anyStr {"pretend this was generated by a Realm core exception" };
	if (ManagedExceptionThrower) {
		ManagedExceptionThrower(testcode, (void*)anyStr.data(), anyStr.size());
	}
```

Callback Details - C# side
---------------------

We define a callback delegate type with a simple implementation like:

```
    public delegate void ExceptionThrowerCallback (IntPtr exceptionCode, IntPtr utf8String, IntPtr stringLen);


        [MonoPInvokeCallback (typeof (ExceptionThrowerCallback))]
        unsafe public static void ExceptionThrower(IntPtr exceptionCode, IntPtr utf8String, IntPtr stringLen)
        {
            //TODO in the real version this switch will throw different exceptions
            if ((Int64)stringLen > 0) {
                throw new SampleNativeException((Int64)exceptionCode, 
                    new String((sbyte*)utf8String, 0 /* start offset */, (int)stringLen, Encoding.UTF8));
            }
            throw new SampleNativeException((Int64)exceptionCode);
        }
```

This delegate is passed to our native side with a function that just needs invoking once, say from our `App` constructor.

```
    [DllImport(EXCEPTIONS_LIB)]
    public static extern void set_exception_thrower(ExceptionThrowerCallback callback);
    
    public static void SetupExceptionThrower()
    {
        set_exception_thrower (ExceptionThrower);
    }
```



Java Exceptions
---------------------------

Java is able to throw exceptions back through the JNI interface which it does through the `ThrowException` function

To get to that point, it usually  maps exceptions through a very lightweight macro  `CATCH_STD`  invoking  `ConvertException` . As seen in the diagram below, this rethrows the exception so it can catch different types.

A few other exceptions are caught by `CATCH_FILE`  which includes a range of catch clauses and thus directly calls `ThrowExcaption`.

@dot
digraph { 
  node[shape = box]
  edge[arrowhead=vee]
  
/* c++ */
node [fontcolor="blue", color="blue"]
coreException [label="a std::exception\n thrown from core"]
CATCH_FILE
CATCH_STD

"Binding invalid\n parameter detection"-> ThrowException
coreExcep ion -> CATCH_FILE -> ThrowException
coreException -> CATCH_STD -> ConvertException

ConvertException -> ConvertException [label=" Rethrows exception"]
ConvertException -> ThrowException [label=" after catching\n rethrown exception"]
ThrowException -> "JNIEnv::FindException" [label=" lookup Java\n exception class"]
ThrowException -> "JNIEnv::ThrowNew" 

  /*  Java */
node [fontcolor="orange", color="orange"]
"JNIEnv::FindException" -> "Namespaced Java\n Exceptions"
"JNIEnv::ThrowNew" -> "Exception should be\n caught by user code" [style=dotted]
}

@enddot

